<?php
/**
 * eep/modules/books/index.php
 */

define( "KOBO_CATALOG_PROGRAMNAME_ROW", 0 );
define( "KOBO_CATALOG_PROGRAMURL_ROW", 1 );
define( "KOBO_CATALOG_CATALOGNAME_ROW", 2 );
define( "KOBO_CATALOG_LASTUPDATED_ROW", 3 );
define( "KOBO_CATALOG_NAME_ROW", 4 );
define( "KOBO_CATALOG_KEYWORDS_ROW", 5 );
define( "KOBO_CATALOG_DESCRIPTION_ROW", 6 );
define( "KOBO_CATALOG_SKU_ROW", 7 );
define( "KOBO_CATALOG_MANUFACTURER_ROW", 8 );
define( "KOBO_CATALOG_MANUFACTURERID_ROW", 9 );
define( "KOBO_CATALOG_UPC_ROW", 10 );
define( "KOBO_CATALOG_ISBN_ROW", 11 );
define( "KOBO_CATALOG_CURRENCY_ROW", 12 );
define( "KOBO_CATALOG_SALEPRICE_ROW", 13 );
define( "KOBO_CATALOG_PRICE_ROW", 14 );
define( "KOBO_CATALOG_RETAILPRICE_ROW", 15 );
define( "KOBO_CATALOG_FROMPRICE_ROW", 16 );
define( "KOBO_CATALOG_BUYURL_ROW", 17 );
define( "KOBO_CATALOG_IMPRESSIONURL_ROW", 18 );
define( "KOBO_CATALOG_IMAGEURL_ROW", 19 );
define( "KOBO_CATALOG_ADVERTISERCATEGORY_ROW", 20 );
define( "KOBO_CATALOG_THIRDPARTYID_ROW", 21 );
define( "KOBO_CATALOG_THIRDPARTYCATEGORY_ROW", 22 );
define( "KOBO_CATALOG_AUTHOR_ROW", 23 );
define( "KOBO_CATALOG_ARTIST_ROW", 24 );
define( "KOBO_CATALOG_TITLE_ROW", 25 );
define( "KOBO_CATALOG_PUBLISHER_ROW", 26 );
define( "KOBO_CATALOG_LABEL_ROW", 27 );
define( "KOBO_CATALOG_FORMAT_ROW", 28 );
define( "KOBO_CATALOG_SPECIAL_ROW", 29 );
define( "KOBO_CATALOG_GIFT_ROW", 30 );
define( "KOBO_CATALOG_PROMOTIONALTEXT_ROW", 31 );
define( "KOBO_CATALOG_STARTDATE_ROW", 32 );
define( "KOBO_CATALOG_ENDDATE_ROW", 33 );
define( "KOBO_CATALOG_OFFLINE_ROW", 34 );
define( "KOBO_CATALOG_ONLINE_ROW", 35 );
define( "KOBO_CATALOG_INSTOCK_ROW", 36 );
define( "KOBO_CATALOG_CONDITION_ROW", 37 );
define( "KOBO_CATALOG_WARRANTY_ROW", 38 );
define( "KOBO_CATALOG_STANDARDSHIPPINGCOST_ROW", 39 );

class book_commands
{
    const books_addcontriblookup           = "addcontriblookup";
    const books_addcontribdisambiguation   = "addcontribdisambiguation";
    const books_nodeswithreviews           = "nodeswithreviews";
    const books_convertnodeid2isbn         = "convertnodeid2isbn";
    const books_convertisbn2importid       = "convertisbn2importid";
    const books_convertisbn2nodeid         = "convertisbn2nodeid";
    const books_echoimportcommand          = "echoimportcommand";
    const books_downloadisbn               = "downloadisbn";
    const books_convertcontrib2isbn        = "convertcontrib2isbn";
    const books_listmissingproductrecords  = "listmissingproductrecords";
    const books_queuefordownload           = "queuefordownload";
    const books_updateeanfiles             = "updateeanfiles";
    const books_repairfirstname            = "repairfirstname";

    const books_resetkobolookup            = "resetkobolookup";
    const books_importkobolink             = "importkobolink";
    const books_importkobocatalog          = "importkobocatalog";

    const books_importindigolink           = "importindigolink";
    const books_importamazonlinks          = "importamazonlinks";
    const books_importkindlelink           = "importkindlelink";

    const books_updatepublink              = "updatepublink";

    const books_repairdegeneratecontribs_1 = "create_contrib_list";
    const books_repairdegeneratecontribs_2 = "process_orphans";
    const books_repairdegeneratecontribs_3 = "clean_singles";
    const books_repairdegeneratecontribs_4 = "purge_degenerates";

    //--------------------------------------------------------------------------
    var $availableCommands = array
    (
        "help"
        , self::books_addcontriblookup
        , self::books_addcontribdisambiguation
        , self::books_convertcontrib2isbn
        , self::books_convertisbn2importid
        , self::books_convertisbn2nodeid
        , self::books_convertnodeid2isbn
        , self::books_downloadisbn
        , self::books_echoimportcommand
        , self::books_listmissingproductrecords
        , self::books_nodeswithreviews
        , self::books_queuefordownload
        , self::books_repairfirstname
        , self::books_updateeanfiles

        , self::books_resetkobolookup
        , self::books_importkobolink
        , self::books_importkobocatalog

        , self::books_importindigolink
        , self::books_importamazonlinks
        , self::books_importkindlelink

        , self::books_updatepublink

        , self::books_repairdegeneratecontribs_1
        , self::books_repairdegeneratecontribs_2
        , self::books_repairdegeneratecontribs_3
        , self::books_repairdegeneratecontribs_4
    );
    var $help = "";                     // used to dump the help string

    //--------------------------------------------------------------------------
    public function __construct()
    {
        $parts = explode( "/", __FILE__ );
        array_pop( $parts );
        $command = array_pop( $parts );

$this->help = <<<EOT

--------------------------------------------------------------------------------
special process: clean degenerate contribs:
remove contribs that are the same person with two objects

REMEMBER: do, one time only:
eep books repairfirstname <object id>

step 1: dump full contributor list to a file, eg:
eep books create_contrib_list /home/dfp/contrib_isbn_dump

step 2: extract the orphaned contribs (this creates some cron tasks)
eep books process_orphans /home/dfp/contrib_isbn_dump > /home/dfp/contrib_isbn_dump_noorphans

step 3: sort the list
sort /home/dfp/contrib_isbn_dump_noorphans > /home/dfp/contrib_isbn_dump_sorted

step 4: remove single-instance contributors from the dumpfile
eep books clean_singles /home/dfp/contrib_isbn_dump_sorted > /home/dfp/contrib_isbn_dump_cleaned

step 5: add tasks to:
       (a) delete all the duplicate contribs, and
       (b) redownload and
       (c) reimport the records
eep books purge_degenerates /home/dfp/contrib_isbn_dump_cleaned
--------------------------------------------------------------------------------


addcontriblookup
  eep books addcontriblookup <orig first name> <orig last name> <converted first name> <converted last name> <converted title>
  - note that 'title' is typically: <last name>, <first name>

addcontribdisambiguation
  eep books addcontribdisambiguation <orig first name> <orig last name> <unique label> <isbn or isbn list - comma separated>
  - <unique label> is the internally used label to distinguish contribs with identical names

convertcontrib2isbn
  eep books convertcontrib2isbn <contributor node id>

convertisbn2importid
  eep books convertisbn2importid <isbn or ean>

convertisbn2nodeid
  eep books convertisbn2nodeid <isbn or ean>

convertnodeid2isbn
  eep books convertnodeid2isbn <node id>

downloadisbn
  eep books downloadisbn <isbn>

echoimportcommand
  eep books echoimportcommand <node id>|<isbn>

listmissingproductrecords
  - list all isbns, with result for "have/don't have a product record"

nodeswithreviews
- list of node ids of onix products with review quotes
  (actually: nodes that are the parents of othertexts that are review quotes)
  eep use ezroot <path>
  eep books nodeswithreviews

queuefordownload
- this downloads data from biblioshare and adds crondaemon tasks to do the
  associated imports. This respects --updateall indicating that all records
  should be downloaded and updated thereby ignoring timestamps. The first
  version (with no named file) uses the most recent EAN file in _testdata:
  eep books queuefordownload based on the "can_ean_" convention.
  - this lets you use a specific file.
  eep books queuefordownload <ean file name>

repairfirstname
  eep books repairfirstname <object id>

updateeanfiles
- update local repo of available EAN files from bilioshare

updatepublink
- for a given import id, redo the publisher link
  eep books updatepublink <importid>
--------------------------------------------------------------------------------

resetkobolookup
- remove the lookup table (if it exists), create it again
  eep books resetkobolookup

fetchkobocatalog
- there is no implementation for this; instead you should:
  cd _testdata
  wget http://3129895:zVv6Jjfm@datatransfer.cj.com/datatransfer/files/3129895/outgoing/productcatalog/95772/Kobo_eBooks-Kobo_eBooks_Product_Catalog.txt.gz
  ## (that's username:password)
  gunzip Kobo_eBooks-Kobo_eBooks_Product_Catalog.txt.gz

importkobocatalog
- parses the kobo datafile into the lookup table
  eep books importkobocatalog [<file name>]
  - note that:
    (1) the data file has to be in _testdata, and
    (2) filename is optional and defaults to "Kobo_eBooks-Kobo_eBooks_Product_Catalog.txt"

importkobolink
- attempts to figure out (via a lookup into the local table) and install a kobo
  purchase link for a given product
  eep books importkobolink <object id>

importindigolink
- attempts to get (curl) and install an indigo
  purchase link for a given product
  eep books importindigolink <object id>

importamazonlinks
- attempts to get (curl) and install amazon links
  purchase link for a given product(for both .ca and .com)
  eep books importamazonlinks <object id>

importkindlelink
- attempts to get and install amazon kindle links
  purchase link for a given product
  eep books importkindlelink <object id>

EOT;
    }

    //--------------------------------------------------------------------------
    private function dumpNodesWithReviews()
    {
        $offset = 0;
        $limit = 6000;

        $parentNodeId = 93; // books subtree

        $params[ "ClassFilterType" ] = "include";
        $params[ "ClassFilterArray" ] = array( "onix_othertext" );
        $params[ "Depth" ] = 6;
        $params[ "MainNodeOnly" ] = true;
        $params[ "IgnoreVisibility" ] = true;
        $params[ "AttributeFilter" ] = array
        (
            "and"
            , array( "onix_othertext/texttypecode", "=", "08" )
        );
        $params[ "Limit" ] = $limit;
        $params[ "Offset" ] = $offset;

        $bookNodesWithReviews = array();

        echo "\n";
        $allReviews = eZContentObjectTreeNode::subTreeByNodeID( $params, $parentNodeId );
        do
        {
            foreach( $allReviews as $n=>$reviewNode )
            {
                $bookNodeId = $reviewNode->ParentNodeID;
                if( isset($bookNodesWithReviews[$bookNodeId]) )
                {
                    $bookNodesWithReviews[$bookNodeId] += 1;
                }
                else
                {
                    $bookNodesWithReviews[$bookNodeId] = 1;
                }
                //echo sprintf( "%05d", $offset+$n ) . "\r";
            }
            $offset += $limit;
            $params[ "Offset" ] = $offset;

            $allReviews = eZContentObjectTreeNode::subTreeByNodeID( $params, $parentNodeId );
        }
        while( 0 < count($allReviews) );

        // remove books with only one review
        foreach( $bookNodesWithReviews as $bookNodeId => $count )
        {
            if( 1 == $count )
            {
                unset( $bookNodesWithReviews[$bookNodeId] );
            }
        }
        echo "\nCOUNT of parent nodes:" . count($bookNodesWithReviews) . "\n";
        foreach( $bookNodesWithReviews as $nodeId => $count )
        {
            echo $this->echoimportcommand( $nodeId );
            echo "\n";
        }
        echo "DONE.\n";
    }

    //--------------------------------------------------------------------------
    private function convertnodeid2isbn( $nodeId )
    {
        if( !eepValidate::validateContentNodeId( $nodeId ) )
            throw new Exception( "This is not an node id: [" .$nodeId. "]" );

        $object = eZContentObject::fetchByNodeID( $nodeId );
        $dataMap = $object->dataMap();
        return $dataMap["isbn"]->DataText;
    }

    //--------------------------------------------------------------------------
    private function convertisbn2importid( $isbn )
    {
        if( 13 != strlen($isbn) )
            throw new Exception( "This is not an isbn: [" .$isbn. "]" );

        $db = eZDB::instance();
        $importIdRow = $db->arrayQuery( "SELECT product_index FROM onix_data_staging WHERE product_ean13='".$isbn."'" );
        return $importIdRow[0][ "product_index" ];
    }

    //--------------------------------------------------------------------------
    private function convertisbn2nodeid( $isbn )
    {
        if( 13 != strlen($isbn) )
            throw new Exception( "This is not an isbn: [" .$isbn. "]" );

        $params[ "ClassFilterType" ] = "include";
        $params[ "ClassFilterArray" ] = array( "onix_product" );
        $params[ "MainNodeOnly" ] = true;
        $params[ "IgnoreVisibility" ] = true;
        $params[ 'Limitation' ] = array();
        $params[ "AttributeFilter" ] = array( array( "onix_product/isbn", "=", $isbn ) );

        $parent = 93;

        $matches = eZContentObjectTreeNode::subTreeByNodeID( $params, $parent );
        $node = $matches[0];

        return $node->MainNodeID;
    }

    //--------------------------------------------------------------------------
    private function echoimportcommand( $nodeId )
    {
        if( 13 == strlen($nodeId) )
        {
            $isbn = $nodeId;
        }
        else
        {
            $isbn = $this->convertnodeid2isbn( $nodeId );
        }
        $importId = $this->convertisbn2importid( $isbn );
        if( $importId )
        {
            return "php runcronjobs.php oniximport --specificrecord=" . $importId ;
        }
        else
        {
            return "";
        }
    }

    //--------------------------------------------------------------------------
    private function downloadisbn( $ean )
    {
        chdir( "/home/dfp/http/bookshelf" );
        $cmd = "php runcronjobs.php importfeed --biblioshare --ean=" . $ean;
        $result = `$cmd`;
        echo "\n" .  $result . "\n";
    }

    //--------------------------------------------------------------------------
    private function convertcontrib2isbn( $param1 )
    {
        $contribObject = eZContentObject::fetchByNodeID( $param1, true );

        if( !$contribObject )
        {
            return false;
        }

        // get the reverse related products assoc with this contrib
        $fromObjectVersion = false;
        $attributeID = 363;   // onix_product/contributors
        $groupByAttribute = false;
        $params[ "AllRelations" ] = false;
        $reverseRelatedObjects = true;
        $allReverseRelatedProducts = $contribObject->relatedObjects
        (
            $fromObjectVersion
            , $objectID
            , $attributeID
            , $groupByAttribute
            , $params
            , $reverseRelatedObjects
        );

        echo "\n";

        //echo $contribObject->Name . "---";

        $comma = "";
        foreach( $allReverseRelatedProducts as $aProduct )
        {
            $datamap = $aProduct->DataMap();
            echo $comma . $datamap["isbn"]->DataText;
            $comma = "\n";
        }
    }

    //--------------------------------------------------------------------------
    private function listmissingproductrecords()
    {

        //$listCount = eZContentObject::fetchSameClassListCount( 52 );
        //echo "LISTCOUNT:" . $listCount . "\n";

        // fetchList( $asObject = true, $conditions = null, $offset = false, $limit = false )

        $asObject = false;
        $conditions = array( "contentclass_id" => 52 );
        $offset = false;
        $limit = false;

        $list = eZContentObject::fetchList( $asObject, $conditions, $offset, $limit );
        //echo "LISTCOUNT++:" . count($list) . "\n";

        foreach( $list as $n => $product )
        {
            $object = eZContentObject::fetch( $product["id"] );
            $datamap = $object->DataMap();
            $isbn = $datamap["isbn"]->DataText;

            try
            {
                if( $this->convertisbn2importid( $isbn ) )
                {
                    // we have a product record, so this is an ok record
                    echo sprintf( "%06d", $n ) . "-product_data_exists: " . $isbn . "\n";
                }
                else
                {
                    // we don't have a product record, so this is suspicious
                    echo sprintf( "%06d", $n ) . "-no_product_data: " . $isbn . "\n";
                }
                eZContentObject::clearCache( array( $product["id"] ) );
            }
            catch (Exception $e)
            {
                echo sprintf( "%06d", $n ) . "-ERROR\n";
            }
        }
    }

    //--------------------------------------------------------------------------
    private function dumpContributors( $dumpFile )
    {
        $batchSize = 50;
        $asObject = true;
        $conditions = array( "contentclass_id" => 54 );
        $offset = 0;
        $limit = $batchSize;

        $fh = fopen( $dumpFile, "w" );
        if( !$fh )
        {
            echo "Unable to open file [" . $dumpFile . "]\n";
            return;
        }

        while( $list = eZContentObject::fetchList( $asObject, $conditions, $offset, $limit ) )
        {
            $objectsToClear = array();
            $newOutputLine = "";
            $offset += $batchSize;

            foreach( $list as $n => $contribObject )
            {
                // accumulate list of associated isbns
                echo sprintf( "%05d", $offset+$n ) . "\r";
                $objectsToClear[] = $contribObject->ID;
                $contribDataMap = $contribObject->DataMap();
                $name = trim( $contribDataMap["last_name"]->DataText . ' ' . $contribDataMap["first_name"]->DataText );
                $newOutputLine = $name . ":::" . $contribObject->ID;

                $reverseRelated = $contribObject->relatedObjects
                (
                    false                           // use current version of object
                    , false                         // use current object id
                    , 363                           // attribute id, but we are going to use 'all relations' instead
                    , false                         // return array of objects or a grouped list ... ?
                    , array( "AllRelations"=>true, "Limitation" )
                    , true                          // true->reverse-related and false->related
                );
                if( 0 < count($reverseRelated) )
                {
                    // add the isbns to the line
                    $newOutputLine .= ":::";
                    $comma = "";
                    foreach( $reverseRelated as $productObject )
                    {
                        $objectsToClear[] = $productObject->ID;
                        $productDataMap = $productObject->DataMap();
                        $isbn = $productDataMap["isbn"]->DataText;
                        $newOutputLine .= $comma . $isbn;
                        $comma = ",";
                    }
                }
                // save line in dump file
                fwrite( $fh, $newOutputLine . "\n" );
                // how to avoid memory issues
                eZContentObject::clearCache( $objectsToClear );
            }
        }
        fclose( $fh );
        echo "\nDone.\n";
    }

    //--------------------------------------------------------------------------
    private function process_orphans( $dumpFile )
    {
        $allLines = file( $dumpFile );

        foreach( $allLines as $line )
        {
            $parts = explode( ":::", trim($line) );
            if( 2 == count( $parts ) )
            {
                // delete the contributor subtree
                $object = eZContentObject::fetch( $parts[1] );
                $mainNodeId = $object->mainNodeID();
                if( !$mainNodeId )
                {
                    // this seems pretty quick and to not need to be separate tasks
                    $object->purge();
                }
                else
                {
                    eep::addTask( 'delete orphaned contrib', 'eep contentnode deletesubtree ' .  $mainNodeId, 400 );
                }
            }
            else
            {
                // not an orphan contributor - there are associated isbns
                echo $line;
            }
        }
    }

    //--------------------------------------------------------------------------
    // read the already-sorted dump file,
    // echo all the lines that have a contributor that is used more than once,
    // ie, that is on the line before or after the current line
    private function clean_singles( $dumpFile )
    {
        $allLines = file( $dumpFile );

        for( $n=1; $n<count($allLines)-1; $n+=1 )
        {
            $line = $allLines[$n];
            $parts = explode( ":::", $line );
            if( 0 === strpos( $allLines[$n-1], $parts[0].':::' )        // include the colons so that we don't match with a fraction of some other name
                || 0 === strpos( $allLines[$n+1], $parts[0].':::' ) )
            {
                // the contributor name is repeated, so echo it
                echo $line;
            }
        }
    }

    //--------------------------------------------------------------------------
    // a line looks like:
    // <name>:::<contrib object id>:::<comma sep. list of isbns>
    private function purge_degenerates( $file )
    {
        $allLines = file( $file );

        $accumulatedContribOjectIds = array();
        $accumulatedISBNs = array();
        $previousName = null;
        foreach( $allLines as $n => $line )
        {
            $lineParts = explode( ":::", $line );
            $currentName = $lineParts[0];
            if( is_null( $previousName ) )
            {
                // handle as a separate case to be obvious
                $previousName = $currentName;
                $accumulatedContribOjectIds[] = $lineParts[1];
                $accumulatedISBNs = explode( ",", $lineParts[2] );
            }
            elseif( ($currentName != $previousName) || (count($allLines) == $n+1) )
            {
                // wrap up previous name: delete all the accumulated contributors
                foreach( $accumulatedContribOjectIds as $contribObjectId )
                {
                    $contribObject = eZContentObject::fetch( $contribObjectId );
                    $mainNodeId = $contribObject->mainNodeID();
                    eep::addTask
                    (
                        "delete degenerate contrib"
                        , "eep contentnode deletesubtree " . $mainNodeId
                        , 500
                    );
                }
                // and reimport all the associated isbns
                foreach( $accumulatedISBNs as $isbn )
                {
                    $isbn = trim( $isbn );
                    if( 0 == strlen( $isbn ) ) continue; // possibly unnesc.
                    eep::addTask
                    (
                        "download replacement"
                        , "php runcronjobs.php importfeed --biblioshare --import=550 --ean=" . $isbn
                        , 500
                    );
                }
                // finally, start accumulation based on the next name
                $previousName = $lineParts[0];
                $accumulatedContribOjectIds = array();
                $accumulatedContribOjectIds[] = $lineParts[1];
                $accumulatedISBNs = explode( ",", $lineParts[2] );
            }
            else
            {
                // previous name is the same as the current one so accumulate isbns
                $accumulatedContribOjectIds[] = $lineParts[1];
                $accumulatedISBNs = array_merge( $accumulatedISBNs, explode( ",", $lineParts[2] ) );
            }
        }
    }

    //--------------------------------------------------------------------------
    private function updateeanfiles()
    {
        $path = "./_testdata";

        $currentFiles = array();
        $missingFiles = array();

        // get current list of files:
        $hDir = opendir( $path );
        $file = readdir( $hDir );
        while( false != $file )
        {
            if( !in_array( $file , array(".", "..", ".svn") ))
            {
                $filePath = $path ."/". $file;
                $stat = stat($filePath);
                if( is_file( $filePath ) )
                    $currentFiles[] = $file;
            }
            $file = readdir( $hDir );
        }
        // get list of missing files
        $host = "ftp.biblioshare.org/";
        $user = "can_ean";
        $password = "can123";
        $ftpPath = "ftp://" . $user .":". $password ."@". $host;
        $hRemoteDir = opendir( $ftpPath );
        $file = readdir( $hRemoteDir );
        while( false != $file )
        {
            if( !in_array( $file, $currentFiles ) )
            {
                $missingFiles[] = $file;
            }
            $file = readdir( $hRemoteDir );
        }
        // download the missing files
        if( 0 < count($missingFiles) )
        {
            $conn = ftp_connect( "ftp.biblioshare.org" );
            ftp_login( $conn, $user, $password );
            foreach( $missingFiles as $fileToGet )
            {
                echo "copying file: ".$fileToGet."\n";
                ftp_get( $conn, $path."/".$fileToGet, $fileToGet, FTP_BINARY );
            }
            ftp_close( $conn );
        }
    }

    //--------------------------------------------------------------------------
    /**
     * the file timestamp looks like:
     *   "2011-02-16 18:51:31.090"
     * the staging table timestamp looks like:
     *   2011-02-06 16:20:05
     */
    private function processEANFileRowData( $row )
    {
        $results = array();
        $row = trim( $row );
        $parts = explode( "\t", $row );
        $results[ "EAN" ] = $parts[ 0 ];
        if( 2 == count($parts) )
        {
            $results[ "datetime" ] = substr( $parts[1], 0, -4 );
        }
        return $results;
    }

    //------------------------------------------------------------------------------
    private function getProductRecordFromEAN( $ean )
    {
        $db = eZDB::instance();
        $sql = "";
        $sql .= "SELECT * FROM onix_data_staging \n";
        $sql .= " WHERE product_ean13 = '" . $ean . "'\n";
        $rows = $db->arrayQuery( $sql );
        return $rows[0];
    }

    //------------------------------------------------------------------------------
    function removeProductRecord( $productIndex, $productEAN )
    {
        $db = eZDB::instance();
        $sql = "";
        $sql .= "DELETE FROM onix_data_staging \n";
        $sql .= " WHERE product_index = '" . $productIndex . "'\n";
        $sql .= "  OR product_ean13 = '" . $productEAN . "'\n";

        $db->query( $sql );
    }

    //--------------------------------------------------------------------------
    // todo, support limit and offset --- so that this can be done by the cron
    // daemon
    // todo, output some time info - how much time used, how much remaining
    private function queueeansfromfile( $file = null, $additional )
    {
        $path = "./_testdata";
        if( null == $file )
        {
            // have to determine the most recent file that we have
            $hDir = opendir( $path );
            $file = readdir( $hDir );
            while( false != $file )
            {
                if( strstr( $file, "can_ean_" ))
                {
                    $filePath = $path ."/". $file;
                    $stat = stat($filePath);
                    if( is_file( $filePath ) )
                        $currentFiles[] = $file;
                }
                $file = readdir( $hDir );
            }
            sort( $currentFiles );
            $file = array_pop( $currentFiles );
        }
        echo "Processing: " . $file ."\n";
        $lines = file( $path . "/". $file );
        unset( $lines[0] );
        $count = count($lines);
        foreach( $lines as $n => $line )
        {
            echo sprintf( "%05d", $n ) . "/" , $count . " rows processed\r";
            // support comments in the source file
            if( "#" == substr( $line, 0, 1) ) continue;
            $rowData = $this->processEANFileRowData( $line );
            $productRecord = $this->getProductRecordFromEAN( $rowData[ "EAN" ] );
            if( $productRecord )
            {
                // updateall means: disregard the timestamps and update all records
                if( !isset($additional["updateall"]) )
                {
                    if( $rowData["datetime"] <= $productRecord["product_uploaddate"] )
                    {
                        // our data is uptodate, so skip importing this record
                        continue;
                    }
                }
            }
            $this->removeProductRecord( $productRecord["product_index"], $rowData[ "EAN" ] );
            eep::addTask( "bibshare_download", "php runcronjobs.php importfeed --import=500 --biblioshare --ean=".$rowData[ "EAN" ], 400 );
        }
        echo "\n";
    }

    //--------------------------------------------------------------------------
    private function repairfirstname( $objectId )
    {
        $object = eZContentObject::fetch( $objectId );
        if( $object )
        {
            if( "onix_contributor" == $object->ClassIdentifier )
            {
                $dataMap = $object->attribute( 'data_map' );
                $oldName = $dataMap[ "first_name" ]->toString();
                $newName = Contributor::repairFirstName( $oldName );
                $dataMap[ "first_name" ]->fromString( $newName );
                $dataMap[ "first_name" ]->store();

                if( $oldName != $newName )
                {
                    // update the object name, too
                    $fullName = $dataMap[ "last_name" ]->toString() . ", " . $newName;
                    $dataMap[ "title" ]->fromString( $fullName );
                    $dataMap[ "title" ]->store();
                    $object->setName( $fullName );
                    $object->store(); // this should update the URL

                    eep::republishObject( $objectId );

                    echo "Changed: '" .$oldName. "' to '" .$newName. "'. Publish result:" . serialize($publish) . "";
                }
                else
                {
                    echo "No change";
                }
            }
        }
    }

    private function importamazonlinks( $objectId )
    {
        $bookObject = eZContentObject::fetch( $objectId );
        if( !is_object($bookObject) )
        {
            echo "This is not an object id [" . $objectId . "]\n";
            return;
        }
        $dataMap    = $bookObject->DataMap();
        $isbn        = $dataMap[ 'isbn' ]->attribute( 'data_text' );

        $affiliateCodes = array
        (
            "ca"    => "canadibooks0f-20",
            "com"   => "canadibooksh-20"
        );

        foreach( $affiliateCodes as $code => $affCode )
        {
            $purchaseLinker = new PurchaseLinks();
            $linkData       = $purchaseLinker->createAmazonLink( $code, $isbn );
            $linkAttribute  = $dataMap[ 'amazon_' . $code . '_purchase_link' ];
            $linkAttribute->fromString( $linkData );
            $linkAttribute->store();
        }
    }

    public function importkindlelink( $objectId )
    {
        //the kindle link search works from the biblioshare feed  so we have to retreive it first
        $bookObject = eZContentObject::fetch( $objectId );
        if( !is_object($bookObject) )
        {
            echo "This is not an object id [" . $objectId . "]\n";
            return;
        }
        $dataMap    = $bookObject->DataMap();
        $xml        = $dataMap[ 'book_data' ]->attribute( 'data_text' );
        //remove the extra attribute on the Product because it break the xml parsing
        $xml        = preg_replace( '/(<Product\s[^>]*>)/', '<Product>', $xml );

        $purchaseLinker = new PurchaseLinks();
        $link = $purchaseLinker->createKindleLink( $xml );

        if( $link )
        {
            $linkAttribute = $dataMap[ 'kindle_purchase_link' ];
            $linkAttribute->fromString( $link );
            $linkAttribute->store();
        }
    }

    private function importindigolink( $objectId )
    {
        $bookObject = eZContentObject::fetch( $objectId );
        if( !is_object($bookObject) )
        {
            echo "This is not an object id [" . $objectId . "]\n";
            return;
        }
        $dataMap        = $bookObject->DataMap();
        $isbn           = $dataMap[ 'isbn' ]->attribute( 'data_text' );
        $purchaseLinker = new PurchaseLinks();
        $linkData       = $purchaseLinker->createIndigoLink( $isbn );

        if( $linkData )
        {
            $linkAttribute = $dataMap[ 'indigo_purchase_link' ];
            $linkAttribute->fromString( $linkData );
            $linkAttribute->store();
        }
    }

    //--------------------------------------------------------------------------
    private function importkobolink( $objectId )
    {
        //the kindle link search works from the biblioshare feed  so we have to retreive it first
        $bookObject = eZContentObject::fetch( $objectId );
        if( !is_object($bookObject) )
        {
            echo "This is not an object id [" . $objectId . "]\n";
            return;
        }
        $dataMap    = $bookObject->DataMap();
        $xml        = $dataMap[ 'book_data' ]->attribute( 'data_text' );
        //remove the extra attribute on the Product because it break the xml parsing
        $xml        = preg_replace( '/(<Product\s[^>]*>)/', '<Product>', $xml );

        $purchaseLinker = new PurchaseLinks();
        $link = $purchaseLinker->createKoboLink( $xml );

        if( $link )
        {
            $dataMap[ "kobo_link" ]->FromString( $link );
            $dataMap[ "kobo_link" ]->store();
            eep::republishObject( $objectId );
        }
        elseif( "" != $dataMap[ "kobo_link" ]->ToString() )
        {
            $dataMap[ "kobo_link" ]->FromString( "" );
            $dataMap[ "kobo_link" ]->store();
            eep::republishObject( $objectId );
        }
    }

    //--------------------------------------------------------------------------
    private function resetkobolookup()
    {
        $db = eZDB::instance();

        $tableSQL = "DROP TABLE IF EXISTS `onix_kobolookup`; \n";
        $result = $db->query( $tableSQL );
        //var_dump($result );

        $tableSQL = "";
        $tableSQL .= "CREATE TABLE IF NOT EXISTS `onix_kobolookup` ( \n";
        $tableSQL .= "  `index` int(11) NOT NULL AUTO_INCREMENT, \n";
        $tableSQL .= "  `product_name` varchar(255) NOT NULL, \n";
        $tableSQL .= "  `contributor` varchar(255) NOT NULL, \n";
        $tableSQL .= "  `purchase_url` varchar(255) NOT NULL, \n";
        $tableSQL .= "  INDEX (product_name), \n";
        $tableSQL .= "  INDEX (contributor), \n";
        $tableSQL .= "  PRIMARY KEY (`index`) \n";
        $tableSQL .= ") ENGINE=InnoDB  DEFAULT CHARSET=utf8; \n";
        $result = $db->query( $tableSQL );
        //var_dump($result );
    }

    //--------------------------------------------------------------------------
    private function importkobocatalog( $fileName = "Kobo_eBooks-Kobo_eBooks_Product_Catalog.txt" )
    {
        $path = "./_testdata/";
        $hfile = fopen( $path . $fileName, "r" );
        if( !$hfile ) throw new Exception( "Failed to open file '" .$fileName. "' on path '" .$path. "'" );

        $db = eZDB::instance();

        $n = 1;
        $line = fgets( $hfile );
        while( false !== $line )
        {
            //echo "Processing line: " , sprintf( "%08d", $n ) . "\r";

            if( strlen( $line ) <= 1 || strstr( $line, "dev.kobobooks.com" ) )
            {
                // skipping this line since there's something wrong with it
                echo $line . "\n";
            }
            else
            {
                $parts = explode( "\",\"", $line );

                // install only CAD links
                if( "CAD" == $parts[KOBO_CATALOG_CURRENCY_ROW] )
                {
                    $testSql = "select product_name from onix_kobolookup where product_name='" . $db->escapeString( $parts[KOBO_CATALOG_NAME_ROW] ) . "' and contributor='" . $db->escapeString( $parts[KOBO_CATALOG_AUTHOR_ROW] ) . "' limit 1";
                    $testRow = $db->arrayQuery( $testSql );
                    if( 0 < count($testRow) )
                    {
                        // update existing
                        $sql = "UPDATE onix_kobolookup ";
                        $sql .= " SET ";
                        $sql .= " purchase_url='" . $db->escapeString( $parts[KOBO_CATALOG_BUYURL_ROW] ) . "'";
                        $sql .= " WHERE product_name='" . $db->escapeString( $parts[KOBO_CATALOG_NAME_ROW] ) . "'";
                        $sql .= " AND contributor='" . $db->escapeString( $parts[KOBO_CATALOG_AUTHOR_ROW] ) . "'";
                        $db->query( $sql );
                    }
                    else
                    {
                        $sql = "INSERT INTO onix_kobolookup ";
                        $sql .= " SET ";
                        $sql .= " product_name='" . $db->escapeString( $parts[KOBO_CATALOG_NAME_ROW] ) . "'";
                        $sql .= " , contributor='" . $db->escapeString( $parts[KOBO_CATALOG_AUTHOR_ROW] ) . "'";
                        $sql .= " , purchase_url='" . $db->escapeString( $parts[KOBO_CATALOG_BUYURL_ROW] ) . "'";
                        $db->query( $sql );
                    }
                }
            }
            $n += 1;
            $line = fgets( $hfile );
        }
        fclose( $hfile );
        echo "\n";
    }

    //--------------------------------------------------------------------------
    private function updatepublink( $Id )
    {
        $db = eZDB::instance();
        $productAttributes = array
        (
            "publisher_book_purchase_link"  => ""
            , "publisher_purchase_link"     => ""
        );

        // try to get the data from stage table
        if( 13 == strlen($Id) )
        {
            $importRow = $db->arrayQuery( "SELECT * FROM onix_data_staging WHERE product_ean13=".$Id );
            if( 0 == count($importRow) )
            {
                throw new Exception( "Invalid import isbn: " . $Id );
            }
            $isbn = $importRow[0]["product_ean13"];
        }
        else
        {
            $importRow = $db->arrayQuery( "SELECT * FROM onix_data_staging WHERE product_index=".$Id );
            if( 0 == count($importRow) )
            {
                throw new Exception( "Invalid import id: " . $Id );
            }
            $isbn = $importRow[0]["product_ean13"];
        }
        // try to get the onix_product based on the isbn
        $booksSubtree = 93;
        $params[ "ClassFilterType" ] = "include";
        $params[ "ClassFilterArray" ] = array( "onix_product" );
        $params[ "Depth" ] = 3;
        $params[ "MainNodeOnly" ] = true;
        $params[ "IgnoreVisibility" ] = true;
        $params[ "AttributeFilter" ] = array
        (
            "and"
            , array( "onix_product/isbn", "=", $isbn )
        );
        $theBookMatches = eZContentObjectTreeNode::subTreeByNodeID( $params, $booksSubtree );

        if( 0 == count($theBookMatches) )
        {
            throw new Exception( "Failed to fetch content object for isbn: " . $isbn );
        }
        $theBook = $theBookMatches[0];
        // try to extract the publisher links from the xml
        $xml = $importRow[0]["product_xml"];
        libxml_use_internal_errors( true );
        $aDOMDocument = new DOMDocument();
        $aDOMDocument->preserveWhiteSpace = false;
        $aDOMDocument->formatOutput = true;
        if( !$aDOMDocument->loadXML( $xml ) )
        {
            $errs = libxml_get_errors();
            throw new Exception( "Failed to parse xml: " . serialize($errs) );
        }
        // ... use xpath
        // get the publisher name for display
        $xpath = new DOMXPath( $aDOMDocument );
        $publisherNamePath = "/Product/Publisher[PublishingRole='01']/PublisherName";
        $publisherName = $xpath->query( $publisherNamePath );
        $publisherNameDisp = $publisherName->item(0)->nodeValue;
        // get publisher's specific book link
        $specificLinkPath = "/Product/Website[WebsiteRole='02']/WebsiteLink";
        $specificLink = $xpath->query( $specificLinkPath );
        $specificLinkUrl = $specificLink->item(0)->nodeValue;
        if( 0<strlen($publisherNameDisp) && 0<strlen($specificLinkUrl) )
        {
            $productAttributes[ "publisher_book_purchase_link" ] = serialize( array( "display"=>$publisherNameDisp, "url"=>$specificLinkUrl, "icon_type"=>"default" ) );
        }
        // get publisher's generic link
        $genericLinkPath = "/Product/Publisher[PublishingRole='01']/Website[WebsiteRole='01']/WebsiteLink";
        $genericLink = $xpath->query( $genericLinkPath );
        $genericLinkUrl = $genericLink->item(0)->nodeValue;
        if( 0<strlen($publisherNameDisp) && 0<strlen($genericLinkUrl) )
        {
            $productAttributes[ "publisher_purchase_link" ] = serialize( array( "display"=>$publisherNameDisp, "url"=>$genericLinkUrl, "icon_type"=>"default" ) );
        }
        // update the onix_product
        $dataMap = $theBook->attribute( 'data_map' );
        foreach( $productAttributes as $attrName => $value )
        {
            $dataMap[ $attrName ]->fromString( $value );
            $dataMap[ $attrName ]->store();
        }
        eep::republishObject( $theBook->ContentObjectID );
        echo "done\n";
    }

    //--------------------------------------------------------------------------
    public function run( $argv, $additional )
    {
        $command = @$argv[2];
        $param1 = @$argv[3];
        $param2 = @$argv[4];
        $param3 = @$argv[5];
        $param4 = @$argv[6];
        $param5 = @$argv[7];

        if( !in_array( $command, $this->availableCommands ) )
        {
            throw new Exception( "Command '" . $command . "' not recognized." );
        }

        $eepCache = eepCache::getInstance();

        switch( $command )
        {
            case "help":
                echo "\nAvailable commands:: " . implode( ", ", $this->availableCommands ) . "\n";
                echo "\n".$this->help."\n";
                break;

            case self::books_listmissingproductrecords:
                $this->listmissingproductrecords();
                break;

            case self::books_nodeswithreviews:
                $this->dumpNodesWithReviews();
                break;

            case self::books_convertnodeid2isbn:
                echo $this->convertnodeid2isbn( $param1 );
                break;

            case self::books_convertisbn2importid:
                echo $this->convertisbn2importid( $param1 );
                echo "\n";
                break;

            case self::books_convertisbn2nodeid:
                echo $this->convertisbn2nodeid( $param1 );
                echo "\n";
                break;

            case self::books_echoimportcommand:
                echo $this->echoimportcommand( $param1 );
                break;

            case self::books_downloadisbn:
                echo $this->downloadisbn( $param1 );
                break;

            case self::books_convertcontrib2isbn:
                echo $this->convertcontrib2isbn( $param1 );
                break;

            case self::books_updateeanfiles:
                echo $this->updateeanfiles();
                break;

            case self::books_repairfirstname:
                $this->repairfirstname( $param1 );
                break;

            case self::books_queuefordownload:
                echo $this->queueeansfromfile( $param1, $additional );
                break;

            case self::books_repairdegeneratecontribs_1:
                $this->dumpContributors( $param1 );
                break;

            case self::books_repairdegeneratecontribs_2:
                $this->process_orphans( $param1 );
                break;

            case self::books_repairdegeneratecontribs_3:
                $this->clean_singles( $param1 );
                break;

            case self::books_repairdegeneratecontribs_4:
                $this->purge_degenerates( $param1 );
                break;

            case self::books_addcontriblookup:
                if( 0 == strlen($param1) ) throw new Exception( "Missing 1st parameter (target first name)" );
                if( 0 == strlen($param2) ) throw new Exception( "Missing 2nd parameter (target last name)" );
                if( 0 == strlen($param3) ) throw new Exception( "Missing 3rd parameter (replacement first name)" );
                if( 0 == strlen($param4) ) throw new Exception( "Missing 4th parameter (replacement last name)" );
                if( 0 == strlen($param5) ) throw new Exception( "Missing 5th parameter (replacement title)" );
                Contributor::addContributorNameLookup( $param1, $param2, $param3, $param4, $param5 );
                break;

            case self::books_addcontribdisambiguation:
                if( 0 == strlen($param1) ) throw new Exception( "Missing 1st parameter (target first name)" );
                if( 0 == strlen($param2) ) throw new Exception( "Missing 2nd parameter (target last name)" );
                if( 0 == strlen($param2) ) throw new Exception( "Missing 2nd parameter (distinguishing string)" );
                if( 0 == strlen($param3) ) throw new Exception( "Missing 4rd parameter (isbn or isbns -- comma separated)" );
                Contributor::addContributorNameDisambiguate( $param1, $param2, $param3, $param4 );
                break;

            case self::books_resetkobolookup:
                $this->resetkobolookup();
                break;

            case self::books_importkobolink:
                $this->importkobolink( $param1 );
                break;

            case self::books_importkobocatalog:
                if( 0 == strlen($param1) )
                {
                    $this->importkobocatalog();
                }
                else
                {
                    $this->importkobocatalog( $param1 );
                }
                break;

            case self::books_importindigolink:
                try
                {
                    $this->importindigolink( $param1 );
                }
                catch( Exception $e )
                {
                    echo $e->getMessage() . "\n";
                }
                break;

            case self::books_importamazonlinks:
                try
                {
                    $this->importamazonlinks( $param1 );
                }
                catch( Exception $e )
                {
                    echo $e->getMessage() . "\n";
                }
                break;

            case self::books_importkindlelink:
                try
                {
                    $this->importkindlelink( $param1 );
                }
                catch( Exception $e )
                {
                    echo $e->getMessage() . "\n";
                }
                break;

            case self::books_updatepublink:
                $this->updatepublink( $param1 );
                break;
        }
    }
}

//------------------------------------------------------------------------------
$operation = new book_commands();
if( !isset($argv[2]) )
{
    $argv[2] = "help";
}
$additional = eep::extractAdditionalParams( $argv );
$operation->run( $argv, $additional );
?>